services:
  # ===========================================
  # Docker Socket Proxy (handles API version negotiation)
  # Required because Traefik's internal Docker client doesn't respect
  # DOCKER_API_VERSION env var and uses hardcoded 1.24
  # ===========================================
  dockerproxy:
    image: tecnativa/docker-socket-proxy:latest
    container_name: dockerproxy
    restart: unless-stopped
    profiles:
      - with-domain
    privileged: true
    environment:
      # Grant read access to containers, networks, services for Traefik
      - CONTAINERS=1
      - NETWORKS=1
      - SERVICES=1
      - TASKS=1
      - INFO=1
      - VERSION=1
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - xorng-network

  # ===========================================
  # Traefik Reverse Proxy (automatic HTTPS)
  # Only used when AUTOMATION_DOMAIN is set
  # ===========================================
  traefik:
    image: traefik:v3.2
    container_name: traefik
    restart: unless-stopped
    profiles:
      - with-domain  # Only starts when profile is active
    depends_on:
      - dockerproxy
    command:
      # API and Dashboard (for debugging)
      - "--api.insecure=true"
      - "--log.level=INFO"
      # Docker provider - connect via socket proxy instead of direct socket
      - "--providers.docker=true"
      - "--providers.docker.endpoint=tcp://dockerproxy:2375"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=xorng-network"
      # Entry points
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      # ACME / Let's Encrypt - HTTP Challenge
      # NOTE: Do NOT redirect HTTP globally when using HTTP challenge!
      # The ACME challenge needs port 80 accessible at /.well-known/acme-challenge/
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL:-admin@${AUTOMATION_DOMAIN}}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"  # Traefik dashboard for debugging
    volumes:
      - letsencrypt:/letsencrypt
    networks:
      - xorng-network

  # ===========================================
  # XORNG Automation Server (Webhook + Orchestrator)
  # Dynamically discovers and deploys services
  # ===========================================
  automation-server:
    image: ${AUTOMATION_IMAGE:-ghcr.io/xorng/xorng-automation:latest}
    container_name: xorng-automation
    restart: unless-stopped
    # Run as root to access Docker socket (required for service orchestration)
    user: root
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
      - GH_ORG=${GH_ORG:-XORNG}
      - WEBHOOK_SECRET=${WEBHOOK_SECRET}
      - WEBHOOK_URL=${WEBHOOK_URL:-https://${AUTOMATION_DOMAIN}/webhook/github}
      - PORT=3000
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - REDIS_URL=redis://redis:6379
      # Dynamic service discovery settings
      - SERVICE_DISCOVERY_ENABLED=true
      - REGISTRY_URL=ghcr.io
      - AUTO_DEPLOY_SERVICES=true
    depends_on:
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    # Mount Docker socket so automation can manage other containers
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - xorng-network
    labels:
      # HTTPS Router
      - "traefik.enable=true"
      - "traefik.docker.network=xorng-network"
      - "traefik.http.routers.automation.rule=Host(`${AUTOMATION_DOMAIN}`)"
      - "traefik.http.routers.automation.entrypoints=websecure"
      - "traefik.http.routers.automation.tls=true"
      - "traefik.http.routers.automation.tls.certresolver=letsencrypt"
      - "traefik.http.services.automation.loadbalancer.server.port=3000"
      # HTTP Router for ACME challenge (NO redirect - required for Let's Encrypt)
      - "traefik.http.routers.automation-http.rule=Host(`${AUTOMATION_DOMAIN}`)"
      - "traefik.http.routers.automation-http.entrypoints=web"
      - "traefik.http.routers.automation-http.service=automation"
      # HTTP to HTTPS redirect middleware (applied AFTER ACME challenge paths)
      - "traefik.http.middlewares.automation-redirect.redirectscheme.scheme=https"
      - "traefik.http.middlewares.automation-redirect.redirectscheme.permanent=true"
      - "traefik.http.routers.automation-http.middlewares=automation-redirect"
    ports:
      - "${AUTOMATION_PORT:-3001}:3000"

  # ===========================================
  # Redis for memory/state
  # ===========================================
  redis:
    image: redis:7-alpine
    container_name: xorng-redis
    restart: unless-stopped
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - xorng-network

# ===========================================
# NOTE: Validators, Knowledge, Task services are NOT defined here!
# They are dynamically discovered and deployed by the automation-server
# based on:
#   1. GitHub org repositories with specific topics (xorng-validator, xorng-knowledge, etc.)
#   2. Container registry images matching pattern ghcr.io/xorng/xorng-*
#   3. Repository package.json/Dockerfile presence
#
# The automation-server will:
#   - Scan the org for service repos
#   - Build/pull images as needed
#   - Deploy services with proper networking
#   - Register them with Traefik automatically
# ===========================================

volumes:
  redis-data:
  letsencrypt:

networks:
  xorng-network:
    driver: bridge
    name: xorng-network  # Explicit name prevents Docker Compose from prefixing with project name
